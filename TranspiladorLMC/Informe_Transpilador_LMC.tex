% Informe: Transpilador de Pseudo-código a Ensamblador LMC
% Archivo listo para Overleaf
\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{courier}
\usepackage{fancyhdr}
\usepackage{url}
\geometry{margin=2.5cm}

% Encabezado y pie de página
\pagestyle{fancy}
\fancyhf{}
\lhead{Escuela Politécnica Nacional}
\cfoot{\thepage}

% Configuración de listings
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}

\lstdefinestyle{codeStyle}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegray},
  keywordstyle=\color{blue},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\linespread{0.95}\ttfamily\footnotesize,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=6pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}

\lstdefinelanguage{Pseudo}{
  morekeywords={LEER,IMPRIMIR,SI,ENTONCES,SINO},
  sensitive=false,
}

\lstdefinelanguage{LMC}{
  morekeywords={INP,OUT,LDA,STA,ADD,SUB,BRA,BRP,BRZ,HLT,DAT},
  sensitive=true,
}

\begin{document}

% ---------------- PORTADA ----------------
\begin{titlepage}
  \centering
  \vspace*{2cm}
  {\scshape\LARGE Escuela Politécnica Nacional \par}
  \vspace{1.5cm}
  {\huge\bfseries Transpilador de Pseudo-código a Ensamblador LMC (Little Man Computer)\par}
  \vspace{1.0cm}
  {\Large Arquitectura de Computadores GR1CC \par}
  \vspace{2.0cm}

  {\large\bf Integrantes: \par}
  \vspace{0.4cm}
  {\large Castañeda Morales Juan David \par}
  \vspace{0.2cm}
  {\large Guaján Simbana Harry Nicolás \par}
  \vspace{0.2cm}
  {\large Holguin Sánchez Anthony David \par}
  \vspace{0.2cm}
  {\large Moreta Chango Luis Esteban \par}

  \vspace{2.0cm}
  {\large Fecha de entrega: 12 de Enero de 2026\par}

  \vfill
  {\small Profesor: MARTÍNEZ GORDON RONIE STALIN}
\end{titlepage}

\tableofcontents
\newpage

% ---------------- RESUMEN ----------------
\section*{Resumen}
Este informe presenta el desarrollo de un transpilador (mini-compilador) que traduce pseudo-código simple a ensamblador estándar del modelo \emph{Little Man Computer} (LMC). El sistema lee un archivo de texto con instrucciones de alto nivel (lectura, escritura, asignaciones y condicionales) y emite un archivo con mnemónicos LMC listos para ejecutarse en simuladores web reconocidos. Se incluyen el diseño, la implementación, ejemplos, y un análisis comparativo de eficiencia entre el código generado automáticamente y una versión escrita y optimizada manualmente.

\section{Introducción}
El \textbf{Little Man Computer (LMC)} es un modelo educativo que ilustra la arquitectura de Von Neumann y el ciclo \emph{Fetch-Decode-Execute}. En este proyecto se implementa un transpilador que recibe pseudo-código con operaciones aritméticas básicas y estructuras de control simples, y produce código LMC equivalente. El trabajo busca: (i) reforzar conceptos de arquitectura (buses, memoria unificada, set de instrucciones), (ii) ejercitar el diseño de analizadores y generadores de código, y (iii) medir eficiencia en términos de instrucciones y ciclos de reloj.

\section{Objetivo}
Desarrollar un transpilador en Python que traduzca operaciones matemáticas y lógicas escritas en pseudo-código simple a ensamblador LMC estándar, generando un archivo de salida listo para validarse en el simulador web 101computing LMC (\url{https://101computing.net/LMC/}).

\section{Requerimientos}
\begin{enumerate}[label=\textbf{\arabic*.}]
  \item \textbf{Entrada:} Archivo de texto con pseudo-código. Ejemplo:

\begin{lstlisting}[language=Pseudo,style=codeStyle,caption={Ejemplo de entrada en pseudo-código}]
LEER A
LEER B
SI A > B ENTONCES
  C = A - B
SINO
  C = B - A
IMPRIMIR C
\end{lstlisting}

  \item \textbf{Proceso:} Parseo del pseudo-código y traducción a mnemónicos LMC: \texttt{INP}, \texttt{STA}, \texttt{LDA}, \texttt{ADD}, \texttt{SUB}, \texttt{BRA}, \texttt{BRP}, \texttt{BRZ}, \texttt{OUT}, \texttt{HLT}, \texttt{DAT}.
  \item \textbf{Salida:} Archivo de texto con el código ensamblador LMC listo para ejecutar en el simulador web 101computing LMC.
  \item \textbf{Análisis comparativo:} Para un algoritmo estándar (p.ej., \emph{Multiplicación por sumas sucesivas} o \emph{Sucesión de Fibonacci}), comparar:
  \begin{itemize}
    \item Escenario 1: Código generado por el transpilador.
    \item Escenario 2: Código escrito a mano con optimizaciones.
    \item Entregable: Tabla comparativa de eficiencia (instrucciones vs ciclos F-D-E).
  \end{itemize}
\end{enumerate}

\section{Marco Teórico}
\subsection{Modelo de Von Neumann}
Memoria unificada para datos e instrucciones; CPU con unidad de control y ALU; buses de datos, direcciones y control. El ciclo de instrucción se resume en: búsqueda de instrucción (fetch), decodificación (decode) y ejecución (execute).

\subsection{Conjunto de Instrucciones LMC}
LMC expone mnemónicos como: \texttt{INP}/\texttt{OUT}, \texttt{LDA}/\texttt{STA}, \texttt{ADD}/\texttt{SUB}, saltos \texttt{BRA}/\texttt{BRP}/\texttt{BRZ}, \texttt{HLT} para detener y \texttt{DAT} para reservar memoria/constantes.

\section{Metodología y Diseño}
\subsection{Lenguaje de entrada}
El pseudo-código soportado incluye: \texttt{LEER X}, \texttt{IMPRIMIR X}, asignaciones \texttt{X = Y op Z} con \texttt{op} en \{\texttt{+},\texttt{-},\texttt{*},\texttt{/}\}, y condicionales de la forma \texttt{SI A op B ENTONCES} con \texttt{op} en \{\texttt{>},\texttt{<},\texttt{=},\texttt{>=},\texttt{<=},\texttt{!=}\}, seguidos opcionalmente por bloque \texttt{SINO}.

\subsection{Arquitectura del transpilador}
El proyecto se organiza en módulos Python:
\begin{itemize}
  \item \textbf{parser.py:} Tokeniza y construye operaciones intermedias (leer, imprimir, asignación, condicional).
  \item \textbf{generator.py:} Emite mnemónicos LMC. Implementa suma/resta directa y estrategias por \emph{sumas sucesivas} y \emph{restas sucesivas} para multiplicación y división, respectivamente.
  \item \textbf{main.py:} CLI para leer archivo de entrada y guardar la salida LMC en la carpeta indicada.
  \item \textbf{utils.py:} Utilitarios de E/S y manejo de rutas.
  \item \textbf{gui.py:} Interfaz gráfica (PyQt5) para cargar pseudo-código, ejecutar la traducción y visualizar/guardar el LMC en \texttt{output\_lmc/} por usuario.
\end{itemize}

\subsection{Estrategias de generación}
\begin{itemize}
  \item \textbf{Aritmética (+, -):} Traducción directa usando \texttt{LDA}, \texttt{ADD}/\texttt{SUB}, \texttt{STA}.
  \item \textbf{Multiplicación (*):} Sumas sucesivas con acumulador y contador decreciente (usa temporales y constantes \texttt{CTE0}, \texttt{CTE1}).
  \item \textbf{División (/):} Restas sucesivas hasta que el dividendo parcial sea negativo o cero, incrementando el cociente.
  \item \textbf{Condicionales:} Comparaciones mediante \texttt{LDA}/\texttt{SUB} y saltos con \texttt{BRP}/\texttt{BRZ}/\texttt{BRA} para construir \texttt{ENTONCES}/\texttt{SINO}.
\end{itemize}

\section{Implementación}
\subsection{Ejemplo de entrada}
\begin{lstlisting}[language=Pseudo,style=codeStyle]
LEER A
LEER B
SI A > B ENTONCES
  C = A - B
SINO
  C = B - A
IMPRIMIR C
\end{lstlisting}

\subsection{Salida LMC generada}
\begin{lstlisting}[language=LMC,style=codeStyle]
INP
STA X
INP
STA Y
LDA CTE0
STA P

LOOP    LDA Y
        BRZ FIN
        LDA P
        ADD X
        STA P
        LDA Y
        SUB CTE1
        STA Y
        BRA LOOP

FIN     LDA P
        OUT
        HLT

P   DAT 0
X   DAT
Y   DAT
CTE1 DAT 1
CTE0 DAT 0

\end{lstlisting}



\noindent Estrategia: inicializar acumulador en 0, sumar \texttt{X} repetidamente \texttt{Y} veces, decrementando un contador temporal. El generador usa etiquetas para el bucle y \texttt{CTE0}/\texttt{CTE1}.

\section{Uso y Ejecución}
\subsection{Programa (GUI)}
Esta sección corresponde al uso del programa con interfaz gráfica (\texttt{gui.py}). Desde la ventana principal se puede escribir el pseudo-código o cargar un archivo \texttt{.txt}, seleccionar el nombre de salida y la carpeta del integrante donde guardar, y generar el código LMC visualizándolo en el panel derecho.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\textwidth]{arquifinal1.png}
  \caption{Pantalla inicial: escribir pseudo-código o cargar un archivo \texttt{.txt} para convertir.}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\textwidth]{arquifinal2.png}
  \caption{Selección de nombre de archivo y carpeta del integrante donde se desea guardar.}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\textwidth]{arquifinal3.png}
  \caption{Al generar LMC, el código se visualiza en el programa y además se crea un archivo de texto (\texttt{.lmc}) en la carpeta elegida.}
\end{figure}



\subsection{Validación en simulador}
Copiar el ensamblador generado y validarlo en:
\begin{itemize}
  \item 101computing LMC: \url{https://101computing.net/LMC/}
\end{itemize}
Medir ciclos del ciclo \emph{Fetch-Decode-Execute} y el número de instrucciones ejecutadas.

\section{Análisis Comparativo}
\subsection{Algoritmos evaluados}
\begin{itemize}
  \item Multiplicación por sumas sucesivas.
  \item Sucesión de Fibonacci (versión iterativa básica).
  \item Otros de otros integrantes etc
\end{itemize}

\subsection{ Multiplicación por sumas sucesivas }

\subsubsection{Escenario 1:(programa)}
En este escenario se utiliza el programa para transcompilar el algoritmo de multiplicación por sumas sucesivas. La figura muestra el pseudo-código con la estructura \texttt{MIENTRAS} y el código LMC resultante generado por la herramienta. No se repite el contenido en texto para evitar duplicidad.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\textwidth]{arquifinal4.png}
  \caption{Escenario 1 (programa): pseudo-código con bucle \texttt{MIENTRAS} y salida LMC generada automáticamente.}
\end{figure}

\subsubsection{Escenario 2: (manual optimizado)}
La siguiente figura muestra una versión manual optimizada del mismo algoritmo. Es más eficiente porque simplifica la condición del bucle: en lugar de evaluar con instrucciones adicionales (\texttt{SUB CTE0} y un salto extra), asume que \texttt{Y} nunca será negativa y usa directamente \texttt{LDA Y} seguido de \texttt{BRZ FIN}. Esto elimina trabajo innecesario en cada iteración y reduce ciclos.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\textwidth]{arquifinal5.png}
  \caption{Escenario 2 (manual optimizado): condición del bucle simplificada, menos saltos por iteración.}
\end{figure}

\section{Análisis Comparativo}
\subsection{Multiplicación por sumas sucesivas}

En esta sección se evalúa el desempeño del algoritmo de multiplicación por sumas sucesivas, comparando el código generado por el transpilador frente a la versión optimizada manualmente.

\subsubsection{Cambios entre Códigos}
La diferencia fundamental reside en la gestión del flujo de control y la limpieza de variables:
\begin{itemize}
    \item \textbf{Reducción de Saltos:} El transpilador usa dos evaluaciones (\texttt{BRZ} y \texttt{BRP}) en cada iteración. El optimizado solo usa una (\texttt{BRZ}), eliminando un salto condicional por cada vuelta del bucle.
    \item \textbf{Inicialización de Variables:} El código optimizado incluye \texttt{LDA CTE0} y \texttt{STA P} al inicio. Esto garantiza que el acumulador $P$ empiece en cero, evitando errores de persistencia de datos.
    \item \textbf{Eficiencia en el Acumulador:} El código optimizado evita recargar datos innecesariamente desde la memoria, aprovechando mejor el valor que ya reside en el acumulador durante la ejecución.
\end{itemize}

\subsubsection{Tabla Comparativa de Eficiencia}
A continuación se presentan los datos obtenidos de las pruebas de ejecución para $X=7$ con diferentes multiplicadores ($Y$):

\begin{table}[H]
\centering
\caption{Eficiencia: Transpilador vs. Optimizado ($X=7$)}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Operación} & \textbf{Ciclos FDE (Transp.)} & \textbf{Ciclos FDE (Opt.)} & \textbf{Diferencia} & \textbf{Mejora \%} \\ \hline
$7 \times 0$ & 10 & 11 & -1 & -10.0\% \\ \hline
$7 \times 1$ & 21 & 20 & +1 & 4.7\% \\ \hline
$7 \times 5$ & 65 & 56 & +9 & 13.8\% \\ \hline
$7 \times 25$ & 285 & 236 & +49 & 17.2\% \\ \hline
\end{tabular}
\end{table}

\subsubsection{Análisis de Resultados y Ejecución}
\begin{itemize}
    \item \textbf{Impacto de la Inicialización:} En el caso $7 \times 0$, el código optimizado es un ciclo más lento debido al "costo fijo" de inicializar la variable $P$ a cero. Sin embargo, esto asegura la integridad del resultado.
    \item \textbf{Ganancia Escalar:} La eficiencia del código optimizado es proporcional al valor del multiplicador ($Y$). Por cada incremento en $Y$, el código optimizado ahorra aproximadamente 2 ciclos adicionales frente al transpilador.
    \item \textbf{Rendimiento en Bucles Largos:} En operaciones como $7 \times 25$, la mejora del 17.2\% demuestra que una estructura de bucle más simple reduce significativamente la carga de trabajo del procesador LMC.
\end{itemize}
\section{Discusión}
ANADIR

\section{Conclusiones}
\begin{itemize}

\end{itemize}

\section*{Recomendaciones}
Final

\section*{Referencias}


\end{document}
